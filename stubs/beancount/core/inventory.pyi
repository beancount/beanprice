import enum
from beancount.core import convert as convert
from beancount.core.amount import Amount as Amount
from beancount.core.display_context import DEFAULT_FORMATTER as DEFAULT_FORMATTER
from beancount.core.number import ZERO as ZERO, same_sign as same_sign
from beancount.core.position import Cost as Cost, Position as Position
from typing import Any, Optional

ASSERTS_TYPES: bool

class Booking(enum.Enum):
    CREATED: int = ...
    REDUCED: int = ...
    AUGMENTED: int = ...
    IGNORED: int = ...

class Inventory(dict):
    def __init__(self, positions: Optional[Any] = ...) -> None: ...
    def __iter__(self) -> Any: ...
    def __lt__(self, other: Any) -> Any: ...
    def to_string(self, dformat: Any = ..., parens: bool = ...): ...
    def is_empty(self): ...
    def __bool__(self) -> None: ...
    def __copy__(self): ...
    def is_small(self, tolerances: Any): ...
    def is_mixed(self): ...
    def is_reduced_by(self, ramount: Any): ...
    def __neg__(self): ...
    def __abs__(self): ...
    def __mul__(self, scalar: Any): ...
    def currencies(self): ...
    def cost_currencies(self): ...
    def currency_pairs(self): ...
    def get_positions(self): ...
    def get_only_position(self): ...
    def get_currency_units(self, currency: Any): ...
    def segregate_units(self, currencies: Any): ...
    def split(self): ...
    def reduce(self, reducer: Any, *args: Any): ...
    def average(self): ...
    def add_amount(self, units: Any, cost: Optional[Any] = ...): ...
    def add_position(self, position: Any): ...
    def add_inventory(self, other: Any): ...
    def __add__(self, other: Any): ...
    __iadd__: Any = ...
    @staticmethod
    def from_string(string: Any): ...

from_string: Any

def check_invariants(inv: Any) -> None: ...
